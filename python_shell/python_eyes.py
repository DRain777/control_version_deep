def primes(int kmax):
    cdef int n, k, i
    cdef int p[1000]
    result = []
    if kmax > 1000:
        kmax = 1000
    k = 0
    n = 2
    while k < kmax:
        i = 0
        while i < k and n % p[i] != 0:
            i = i + 1
        if i == k:
            p[k] = n
            k = k + 1
            result.append(n)
        n = n + 1
    return result


## 1 В качестве входных данных функция принимает целое число kmax,
##  представляющее максимальный предел, до которого будут генерироваться простые числа

## 2 Он инициализирует массив pемкостью 1000 для хранения простых чисел.

## 3 Он инициализирует пустой список resultдля хранения найденных простых чисел.

## 4 Если заданное значение kmaxбольше 1000, оно устанавливается kmax равным
## 1000, чтобы гарантировать, что массив p не переполнится.

## 5 Он устанавливает kи nв 0 и 2 соответственно, чтобы начать поиск простых чисел с 2.

## 6 Внешний whileцикл выполняется до тех пор, пока kне будет достигнуто
##  значение kmax, указывающее, что kmaxколичество простых чисел было найдено.

## 7 Внутри внешнего цикла внутренний whileцикл используется для проверки,
## nделится ли на какое-либо число в массиве pдо индекса k. Если оно не
##  делится, оно увеличивает iпеременную.

## 8 Если внутренний цикл завершается без нахождения делителя для n, это означает,
##  n что это простое число.  Он сохраняется nв массиве pпо индексу k, чтобы отслеживать простые
##  числа, найденные до сих пор.    Он добавляется nк resultсписку.
## Он увеличивается kна 1, чтобы перейти к следующему индексу в массиве p.

## 9 Независимо от того, nявляется ли оно простым или нет, оно увеличивается nна 1 для перехода к следующему числу.

##  10 После завершения внешнего цикла он возвращает resultсписок, содержащий простые числа до kmax.


##Таким образом, код генерирует список простых чисел до заданного предела, используя алгоритм решета Эратосфена, где
## простые числа идентифицируются путем проверки того, делятся ли они на ранее найденные простые числа.
##


